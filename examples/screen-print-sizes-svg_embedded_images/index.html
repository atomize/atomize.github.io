<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js">
<!--<![endif]-->

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Maximum Screen Print Sizing</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!--  <link rel="stylesheet" href=""> -->
    <link href="https://fonts.googleapis.com/css?family=Roboto:400" rel="stylesheet">
    <style>
        * {
            font-family: 'Roboto', sans-serif;
            font-weight: 400;
        }

        .noselect {
            -webkit-touch-callout: none;
            /* iOS Safari */
            -webkit-user-select: none;
            /* Safari */
            -khtml-user-select: none;
            /* Konqueror HTML */
            -moz-user-select: none;
            /* Firefox */
            -ms-user-select: none;
            /* Internet Explorer/Edge */
            user-select: none;
            /* Non-prefixed version, currently
                                  supported by Chrome and Opera */
        }

        *,
        *:before,
        *:after {
            box-sizing: border-box;
        }

        body {
            margin: 0px;
            font-family: 'Open Sans', 'sans-serif';
            background-color: #444;
            color: #ffffff;
        }

       h1,h2{
           margin:0px;
           padding: 0px;
       }
        p {
            margin: 0 0 1em 0;
        }

        .wrapper {
            max-width: 95vw;
            margin: 0 auto;
            display: grid;
            grid-gap: 3px;
            align-content: center;
        }
        .header {
            text-align: center;
            font-size: 1.3vw;
        }
        .content {
            max-height: 92vh;
            overflow-y: scroll;
        }
        .footer{
            height: 0px !important;
        }
        @media screen and (max-width: 1025px) {
            .sidebar {
                grid-row: 3 !important;
                max-height: fit-content;
            }
            .content {
            max-height: 62vh;
            overflow-y: scroll;
        }
        .sidebar {
            font-size: 15px !important;
        }
        }

        @media screen and (min-width: 1025px) {

            /* no grid support? */
            .sidebar {
                float: left;
                width: 19.1489%;
            }

            .content {
                float: right;
                width: 100%;
            }

            .wrapper {
                margin: 0 auto;
                grid-template-columns: 1fr 3fr;
            }

            .header,
            .footer {
                grid-column: 1 / -1;
                /* needed for the floated layout */
                clear: both;
            }

        }

        .wrapper>* {
            background-color: rgb(248, 248, 248);
            color: #444;
            border-radius: 5px;
            padding: 20px;
            
            /* needed for the floated layout*/
            margin-bottom: 10px;
        }
        .sidebar {
            font-size: 22px;
        }
        /* We need to set the widths used on floated items back to auto, and remove the bottom margin as when we have grid we have gaps. */
        @supports (display: grid) {
            .wrapper>* {
                width: auto;
                margin: 0;
            }
        }

        #colorpicker {
            grid-area: colors;
            align-content: center;
            text-align: center;

        }



      

        #svg-object {
            width: inherit !important;
        }
    </style>

</head>

<body>
    <div class="wrapper">
        <header class="header"><h2>Manipulating embedded images inside of an external SVG with Javascript & base64 encoding</h2></header>
        <aside class="sidebar">
            <p>Click on any <strong>FRONT</strong> or <strong>BACK</strong> print region (the areas in pink) and choose an image. Change the garment color with the picker below.<p>
                    <div id="colorpicker">
                        <span
                            style="background-image: url('grad-min.png');background-size: 100%;padding:0px; margin-bottom:0px;">
                            <input type="range" min="0" max="359" value="0" id="HUE" style="width:100%;height:20px;">
                        </span>
                        <div height="100%">
                            <canvas class="" id="cpcanvas" style="padding:0px"></canvas>
                        </div>
                    </div>

        </aside>
        <article class="content">
            <div style="width:100%;">
                <object id="svg-object" class="noselect " data="MaximumScreenPrintSizes.svg"
                    type="image/svg+xml"></object>
            </div>
        </article>
        <footer class="footer" style="display:none">
            <input type="file" onchange="previewFile('front')" id="front-input" style="display:none">
            <input type="file" onchange="previewFile('back')" id="back-input" style="display:none">
        </footer>
    </div>



    <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="#">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->




    <!--<input id="sliderx" type="range" min="-2000" max="2000" value="0" oninput="moveSlider(this, 'x')" />
    <input id="slidery" type="range" min="-1000" max="1000" value="0" oninput="moveSlider(this, 'y')" />
    <input id="" type="range" min="0" max="5000" value="" oninput="moveSlider(this, 'width')" />
    <input id="" type="range" min="0" max="5000" value="" oninput="moveSlider(this, 'height')" />
    <input id="" type="range" min="0" max="5000" value="" oninput="moveSlider(this, 'boxwidth')" />
    <input id="" type="range" min="0" max="5000" value="" oninput="moveSlider(this, 'boxheight')" /> -->

    <script type="text/javascript">
        /*COMMENT 1
        // Since the classes of all of our queried SVG elements were set manually, we know the order of classList
        // Four total classes are used to distinguish the front and back regions that have images  
        // from the regions that only show print boundaries [pink boxes]. The classes are:
        // .frontregion .front .backregion .back
        // Knowing each classList[0] = frontregion || backregion, we can set a simple variable to return just 'front/back'
        */

        let svgObject = document.getElementById('svg-object')
        const addListeners = (elArray) => {
            return elArray[1].forEach(function (a) {
                /* console.log(a) */
                a.addEventListener("click", () => { document.getElementById(`${elArray[0]}-input`).click() }, false);
            })
        }
        svgObject.addEventListener('load', function () {
            let svgDoc = svgObject.contentDocument;
            let ifrontregion = svgDoc.querySelectorAll('.front');
            let pfrontregion = svgDoc.querySelectorAll('#printregionsfront>path');
            let ibackregion = svgDoc.querySelectorAll('.back');
            let pbackregion = svgDoc.querySelectorAll('#printregionsback>path');
            let frontregion = [...ifrontregion, ...pfrontregion]
            let backregion = [...ibackregion, ...pbackregion]
            addListeners(['back', backregion])
            addListeners(['front', frontregion])
        })

        let insertImage = (region, base64img) => {
            svgObject.getSVGDocument().querySelector(`#printregions${region}`).style.display = 'none'
            svgObject.getSVGDocument().querySelectorAll(`.${region}`).forEach(x => x.setAttribute('xlink:href', base64img))
        }

        let previewFile = (designLocation) => {
            let file = document.getElementById(`${designLocation}-input`).files[0];
            let reader = new FileReader();
            reader.addEventListener("load", function () {
                let base64img = reader.result;
                insertImage(designLocation, base64img)
            }, false);
            if (file) {
                reader.readAsDataURL(file);
            }
        }
        let changeShirtColor = (color) => {
            let pathsToColor = Array.from(svgObject.getSVGDocument().getElementsByTagName('path'))
            pathsToColor.forEach((x) => {
                ((
                    (x.style.fillRule == 'evenodd' && x.style.stroke) === 'none' ||
                    // These two paths failed to get selected by the conditions above
                    // One is the Adult Short Sleeve fill (path9993) and the other are 
                    // the tiny collar bits that hang outside of the print region on the
                    // 2+ Color All Over Print. Instead of this little hack I could have edited 
                    // the svg to add selectors to these paths that allow them to be obtained
                    // in a single conditional, but this works for now.
                    (x.id === ('path10089')) ||
                    (x.id === ('path9993'))) ?
                    x.style.fill = color :
                    null
                )
            })
            svgObject.getSVGDocument().querySelectorAll("mask>g>path").forEach(x => x.style.fill = 'white')
        }

        function getMousePos(a, c) {
            let b = a.getBoundingClientRect();
            return {
                x: c.clientX - b.left,
                y: c.clientY - b.top
            }
        }

        let cpcanvas = document.getElementById("cpcanvas")
            , cpctx = cpcanvas.getContext("2d")
            , hue = 0
        drawCP(cpctx, hue);
        function drawCP(a, c) {
            let b = a.createLinearGradient(0, 0, a.canvas.width, 0);
            b.addColorStop(0, "#fff");
            b.addColorStop(1, `hsl(${c}, 100%, 50%)`);
            a.fillStyle = b;
            a.fillRect(0, 0, a.canvas.width, a.canvas.height);
            b = a.createLinearGradient(0, 0, 0, a.canvas.height);
            b.addColorStop(0, "rgba(0,0,0,0)");
            b.addColorStop(1, "#000");
            a.fillStyle = b;
            a.fillRect(0, 0, a.canvas.width, a.canvas.height)
        }

        function CPGetPixel(a, c) {
            let b = cpcanvas.clientWidth / cpcanvas.width;
            b = cpctx.getImageData(a / b, c / b, 1, 1).data;
            b = Array.from(b)
            b.pop()
            let rgbString = `rgb(${b.join(',')})`
            return changeShirtColor(rgbString)
        }

        HUE.onchange = function () {
            drawCP(cpctx, this.value)
            console.log(this.value)
            let hueChange = `rgb(${hslToRgb(parseInt(this.value) / 359, 1, .5).join(',')})`
            return changeShirtColor(hueChange)
        }

        cpcanvas.onmousedown = function (a) {
            mousePos = getMousePos(cpcanvas, a);
            CPGetPixel(mousePos.x, mousePos.y);
            cancelMove = function (b) {
                cpcanvas.onmousemove = () => { return };
            }
            cpcanvas.onmousemove = function (a, mousePos) {
                mousePos = getMousePos(cpcanvas, a);
                CPGetPixel(mousePos.x, mousePos.y);
                cpcanvas.onmouseup = function (b) { cancelMove(b) }
                cpcanvas.onabort = function (b) { cancelMove(b) }
                cpcanvas.onmouseleave = function (b) { cancelMove(b) }
            }
        }

        function hslToRgb(h, s, l) {
            let r, g, b;

            if (s == 0) {
                r = g = b = l; // achromatic
            } else {
                let hue2rgb = function hue2rgb(p, q, t) {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                    return p;
                }

                let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                let p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }

            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        /* var moveSlider = function (slider, param) {
            let svgDoc = svgObject.contentDocument;
            var svgEl = svgDoc.getElementById("svg7109");
            let vBoxVals = svgEl.getAttribute('viewBox').split(' ')
            let boxwidth = svgEl.getAttribute('width')
            let boxheight = svgEl.getAttribute('height')
            let values = {
                x: vBoxVals[0],
                y: vBoxVals[1],
                width: vBoxVals[2],
                height: vBoxVals[3],
                boxwidth: boxwidth,
                boxheight: boxheight
            }
            values[param] = slider.value
            svgEl.setAttribute('width', `${values['boxwidth']}`);
            svgEl.setAttribute('height', `${values['boxheight']}`);
            svgEl.setAttribute('viewBox', `${values['x']} ${values['y']} ${values['width']} ${values['height']}`);
        } */

        /*  var ongoingTouches = [];
         function startup() {
             var el = document.getElementById("cpcanvas")
             el.addEventListener("touchstart", handleStart, false);
             el.addEventListener("touchend", handleEnd, false);
             el.addEventListener("touchcancel", handleCancel, false);
             el.addEventListener("touchmove", handleMove, false);
             console.log("initialized.");
         }
         function handleStart(evt) {
             evt.preventDefault();
             console.log("touchstart.");
             var el = document.getElementById("cpcanvas");
             var ctx = el.getContext("2d");
             var touches = evt.changedTouches;

             for (var i = 0; i < touches.length; i++) {
                 console.log("touchstart:" + i + "...");
                 ongoingTouches.push(copyTouch(touches[i]));
                 var color = colorForTouch(touches[i]);
                 ctx.beginPath();
                 ctx.arc(touches[i].pageX, touches[i].pageY, 4, 0, 2 * Math.PI, false);  // a circle at the start
                 ctx.fillStyle = color;
                 ctx.fill();
                 console.log("touchstart:" + i + ".");
             }
         }

         function handleMove(evt) {
             evt.preventDefault();
             var el = document.getElementById("cpcanvas")
             var ctx = el.getContext("2d");
             var touches = evt.changedTouches;

             for (var i = 0; i < touches.length; i++) {
                 var color = colorForTouch(touches[i]);
                 var idx = ongoingTouchIndexById(touches[i].identifier);

                 if (idx >= 0) {
                     console.log("continuing touch " + idx);
                     ctx.beginPath();
                     console.log("ctx.moveTo(" + ongoingTouches[idx].pageX + ", " + ongoingTouches[idx].pageY + ");");
                     ctx.moveTo(ongoingTouches[idx].pageX, ongoingTouches[idx].pageY);
                     console.log("ctx.lineTo(" + touches[i].pageX + ", " + touches[i].pageY + ");");
                     ctx.lineTo(touches[i].pageX, touches[i].pageY);
                     ctx.lineWidth = 4;
                     ctx.strokeStyle = color;
                     ctx.stroke();

                     ongoingTouches.splice(idx, 1, copyTouch(touches[i]));  // swap in the new touch record
                     console.log(".");
                 } else {
                     console.log("can't figure out which touch to continue");
                 }
             }
         }
         function handleEnd(evt) {
             evt.preventDefault();
             log("touchend");
             var el = document.getElementById("cpcanvas")
             var ctx = el.getContext("2d");
             var touches = evt.changedTouches;

             for (var i = 0; i < touches.length; i++) {
                 var color = colorForTouch(touches[i]);
                 var idx = ongoingTouchIndexById(touches[i].identifier);

                 if (idx >= 0) {
                     ctx.lineWidth = 4;
                     ctx.fillStyle = color;
                     ctx.beginPath();
                     ctx.moveTo(ongoingTouches[idx].pageX, ongoingTouches[idx].pageY);
                     ctx.lineTo(touches[i].pageX, touches[i].pageY);
                     ctx.fillRect(touches[i].pageX - 4, touches[i].pageY - 4, 8, 8);  // and a square at the end
                     ongoingTouches.splice(idx, 1);  // remove it; we're done
                 } else {
                     console.log("can't figure out which touch to end");
                 }
             }
         }
         function handleCancel(evt) {
             evt.preventDefault();
             console.log("touchcancel.");
             var touches = evt.changedTouches;

             for (var i = 0; i < touches.length; i++) {
                 var idx = ongoingTouchIndexById(touches[i].identifier);
                 ongoingTouches.splice(idx, 1);  // remove it; we're done
             }
         }
         function colorForTouch(touch) {
             var r = touch.identifier % 16;
             var g = Math.floor(touch.identifier / 3) % 16;
             var b = Math.floor(touch.identifier / 7) % 16;
             r = r.toString(16); // make it a hex digit
             g = g.toString(16); // make it a hex digit
             b = b.toString(16); // make it a hex digit
             var color = "#" + r + g + b;
             console.log("color for touch with identifier " + touch.identifier + " = " + color);
             return color;
         }
         startup() */
    </script>
</body>

</html>